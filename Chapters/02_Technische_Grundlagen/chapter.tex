\chapter{Technische Grundlagen} \label{Technische_Grundlagen}

In diesem Kapitel werden technische Grundlagen erläutert, welche für ein weiteres Verständnis der Kapitel \ref{Defintion der Use-Cases} und \ref{Umsetzung der Use-Cases und Evaluation} erforderlich sind.
\section{Internet Protocol Version 4 (IPv4)} \label{ipv4}

\subsection{Allgemeines und Adressierungsschema}
Das Internet Protocol Version 4 ist im \gls{OSI-Schichtenmodell} auf Schicht 3 (Network) angesiedelt\cite{itu1994}. Es dient der \textit{Paketierung} von Daten und anschließenden Ende-zu-Ende-Vermittlung dieser \textit{Pakete} zwischen Netzwerk-Systemen. Dafür notwendig ist eine Adressierung: eine IPv4-Adresse besteht aus einer 32 Bit-Zahl, welche typischerweise dezimal dargestellt wird in so genannter \glqq dotted decimal\grqq{}-Schreibweise. Dafür wird die Binärzahl in vier Oktette mit einem Punkt aufgeteilt und die jeweiligen Oktette in dezimal umgerechnet.

{\centering 32 Bit Integer:\\
\textbf{00000001 0000001 000000011 00000100}\\
$\Downarrow$\\
\glqq Dotted Binary\grqq{}:\\
\textbf{00000001.00000010.00000011.00000100}\\
$\Downarrow$\\
Dotted Decimal (bekannte Schreibweise):\\
{\textbf{1.2.3.4}}\par}

Mit Hilfe von (Sub-)Netzmasken wird die Netzwerkgröße bestimmt. Ein Host mit der IP-Adresse 1.2.3.4 habe eine Netzmaske von 255.255.255.0. Diese Netzmaske entspricht in dotted binary:

{\centering\textbf{11111111.11111111.11111111.00000000}\par}

Die ersten 24 Bit sind für das Netzwerk reserviert (Network bits), die letzte 8 Bit sind Host bits. Dieses Netzwerk kann somit theoretisch aus $2^8 = 256$ Hosts bestehen, wobei die erste und letzte Adresse reserviert sind (Netzwerk- und Broadcast-Adresse).

Heutzutage üblich ist die so genannte Classless Inter-Domain Routing-Notation (\gls{CIDR}), welche IP-Addresse und Netzmaske vereint. Wenn man die genannten Beispiele aus Adresse und Subnetzmaske zusammenführt, erhält man die IP-Adresse in \gls{CIDR}-Notation: 1.2.3.4/24. /24 entspricht dabei den gesetzten Network bits.

Mit Hilfe der IP-Adresse und Netzmaske lässt sich ermitteln, ob sich ein anderer Host im gleichen \textit{Subnetz} befindet. Dafür berechnet das Betriebssystem die eigene Netzwerkadresse per Bitwise-AND aus eigener IP und Netzmaske. In Listing \ref{own-ip-address-AND-subnet} wird die Netzwerkadresse für die IP-Adresse 1.2.3.4 mit der Netzmaske 255.255.255.0 ermittelt.
%TC:ignore
\begin{listing}[h]
\begin{minted}[breaklines,frame=single]{text}
    00000001.00000010.00000011.00000100
AND 11111111.11111111.11111111.00000000
  = 00000001.00000010.00000011.00000000
  => Netzwerkadresse: 1.2.3.0/24
\end{minted}
\caption{Ermittlung der Netzwerkadresse für 1.2.3.4}
\label{own-ip-address-AND-subnet}
\end{listing}\FloatBarrier
%TC:endignore
Hat man nun zwei Hosts 1.2.3.240 und 8.9.10.23, mit denen eine IP-Verbindung aufgebaut werden soll, so prüft der Initiator zuerst, ob das jeweilige Netz \textit{link-lokal} erreichbar ist, also im gleichen Subnetz liegt. Es verhält sich gleich zum vorherigen Beispiel, nur dass an dieser Stelle die IP der Gegenstelle genutzt wird.\\
Dies passiert analog für die IP-Adresse 1.2.3.240 (s. Listing \ref{local-ip-address-AND-subnet}). Dabei ist die resultierende Netzwerkadresse die gleiche, daher kann das Paket link-lokal zum Ziel gesendet werden.

%TC:ignore
\begin{listing}[h]
\begin{minted}[breaklines,frame=single]{text}
    00000001.00000010.00000011.11110000
AND 11111111.11111111.11111111.00000000
  = 00000001.00000010.00000011.00000000
  => Netzwerkadresse: 1.2.3.0/24
\end{minted}
\caption{Ermittlung der Netzwerkadresse für 1.2.3.240}
\label{local-ip-address-AND-subnet}
\end{listing}\FloatBarrier
%TC:endignore

Für die IP-Adresse 8.9.10.23\label{ip_ausserhalb} hingegen liegt die Netzwerkadresse außerhalb der eigenen (s. Listing \ref{remote-ip-address-AND-subnet}), daher muss das Paket \textit{geroutet} werden:
%TC:ignore
\begin{listing}[h]
\begin{minted}[breaklines,frame=single]{text}
    00001000.00001001.00001010.00010111
AND 11111111.11111111.11111111.00000000
  = 00001000.00001001.00001010.00010111
  => Netzwerkadresse: 8.9.10.0/24
\end{minted}
\caption{Ermittlung der Netzwerkadresse für 8.9.10.23}
\label{remote-ip-address-AND-subnet}
\end{listing}\FloatBarrier
%TC:endignore

\subsection{\gls{RFC} 1918-Adressen}
Ein Großteil der IP-Adressen werden \textit{blockweise} an Provider, Firmen und Forschungseinrichtungen herausgegeben und können fortan im Internet genutzt werden. Mit \gls{RFC} 1918 wurden Blöcke durch die Internet Assigned Numbers Authority (IANA) reserviert, welche ausschließlich für private und firmeninterne Nutzung vorgesehen sind\cite{rfc1918}. Sie werden im Internet nicht geroutet. Es handelt sich dabei um die Blöcke:
\begin{itemize}
\item 10.0.0.0/8
\item 172.16.0.0/12
\item 192.168.0.0/16
\end{itemize}

Auf diese Blöcke wird auch in der Bachelorarbeit zurückgegriffen, um Zugriff auf \textit{interne}, vom Internet \textit{isolierte} Ressourcen zu ermöglichen.

\subsection{IPv4-Routing}

Wie in \ref{ip_ausserhalb} für die IP 8.9.10.23 gefolgert, müssen Pakete, die Ziele in anderen Subnetzen haben, geroutet werden. Dafür besitzen alle Netzwerkteilnehmer eine Routing-Tabelle, um herauszufinden, an welchen \textit{Next-Hop} ein Paket adressiert werden muss.\\
In Abb. \ref{grafik: next_hop_routing} besteht das Netzwerk aus vier Teilnehmern: einem \gls{Client}, einem Server und zwei Routern (R1 und R2). Alle Geräte verwalten eine Routing-Tabelle, in denen die Zielnetze und Next-Hops hinterlegt sind.
Damit weiß der \gls{Client}, dass Pakete für das Netzwerk 192.168.200.0/24 über R1 mit der IP-Adresse 192.168.0.1 geschickt werden müssen. R1 nimmt das Paket an, schaut wiederum in der eigenen Routing-Tabelle nach und schickt das Paket dann weiter an R2, usw. (Rück-)Pakete vom Server zum \gls{Client} durchlaufen die gleiche Prozedur pro Hop.\\
%TC:ignore
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.9]{Figures/next_hop_routing_specific_table.pdf}
  \caption{Next Hop Routing}
  \label{grafik: next_hop_routing}
\end{figure}\FloatBarrier
%TC:endignore
\gls{Client} und Server müssen im Übrigen das Netzwerk 192.168.100.0/30 \textbf{nicht} in ihrer Routing-Tabelle pflegen. Dieses Netzwerk hat ausschließlich eine Relevanz zur Übertragung von Daten zwischen R1 und R2: Man spricht auch von Transfernetzwerken.\\
Dieses Beispiel bringt ein Skalierungsproblem mit sich: Umso mehr Subnetze existieren, in denen Server zu erreichen sind, desto mehr Routen muss der \gls{Client} in der Routing-Tabelle, u.U. manuell gepflegt, vorhalten. Das gleiche gilt für Server, insofern eine Server-zu-Server-Kommunikation erfolgen soll.\\
In der Praxis sieht man kaum noch Endsysteme (darunter fallen \gls{Client} und Server), welche mit solchen \textit{spezifischen} Routen arbeiten. Man überlässt die komplexe Verwaltung von Routing-Tabellen den Routern, während die Endsysteme neben der link-lokalen nur noch die \textit{Default}-Route besitzen. In diese Route 0.0.0.0/0 fallen alle Zielnetzwerke, abgesehen vom link-lokalen Subnetz, und sie zeigt immer auf den lokal erreichbaren Router.\\
Das Setzen der Default Route garantiert allerdings nicht, dass ein Ziel auch wirklich erreicht werden kann, z.B. weil es gar nicht existiert oder das Zielnetzwerk nicht in der Routing-Tabelle eines (Next-Hop-)Routers vorhanden ist. Ein Hilfsprotokoll zur Signalisierung von Erreichbarkeit ist dabei das Internet Control Message Protocol (\gls{ICMP}). Das bekannte Werkzeug \texttt{ping} nutzt Nachrichten in Form von \gls{ICMP} Echo Request und \gls{ICMP} Echo Response, um die Erreichbarkeit via IP eines Endsystems zu prüfen.
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.85]{Figures/next_hop_routing_default_route.pdf}
  \caption{Next Hop Routing mit Default Route}
  \label{grafik: next_hop_routing_with_default_route}
\end{figure}\FloatBarrier

Prinzipiell spielen im IPv4-Routing viele weitere Mechanismen eine zentrale Rolle: Zu nennen wären an dieser Stelle bspw. MAC-Adressen (Ethernet), Address Resolution Protocol (ARP), administrative Distanz und Time-To-Live (TTL). Für diese Ausarbeitung haben die Themen allerdings keine besondere Relevanz.\\

\textbf{\underline{Statisches IP-Routing}}\\
Bei nochmaliger Betrachtung der Abbildung \ref{grafik: next_hop_routing_with_default_route} erkennt man zwei Next-Hop Typen: link-lokal und \glqq IP-Adresse\grqq{}. Die link-lokale Route wird automatisch angelegt, sobald eine Netzwerkschnittstelle mit den entsprechenden Adressparametern konfiguriert wird.\\
Routen hingegen, die als Next-Hop eine IP-Adresse beinhalten, müssen entweder als statische oder dynamische Route den Weg in die Routing-Tabelle finden. Statische Routen sind Routen, bei denen ein Administrator Ziel-Netzwerk und Next-Hop manuell auf den Geräten pflegt.\\
Bis zu einer gewissen Netzwerkgröße lassen sich die Routing-Einträge statisch pflegen. Ab größeren Skalierungen mit vielen Routern und Zielnetzwerken wird die Administration jedoch problematisch. So kann es passieren, dass Router in der Konfiguration vergessen werden oder Routing-Einträge fehlen: dies macht eine Weiterleitung dann unmöglich und die Pakete werden verworfen.\\
Weiterhin bieten statische Routen wenig Flexibilität, wenn Verbindungen ausfallen: Es ist zwar möglich, Backup-Routen zu definieren, die zum gleichen Ziel über einen anderen Next-Hop führen mit Hilfe einer schlechteren \textit{Routing-Metrik}. Allerdings kann man nicht alle \textit{Fallback-Szenarien} des Routings vorab durchdenken.

\textbf{\underline{Dynamisches IP-Routing}}\\
IP-Routing auf Basis von dynamischen Routing-Protokollen kann geschilderte Probleme umgehen, indem manuelle Administrationsaufwände verringert bzw. nicht erforderlich werden. Router, die ein dynamisches Routing-Protokoll nutzen, können gegenüber benachbarten Routern Erreichbarkeit für bestimmte Netzwerke signalisieren. Diese Information wird kaskadiert durch das gesamte Netzwerk getragen und es erhalten alle berechtigten Router einer \textit{Routing-Domäne} die Information, \textit{welche} Netzwerke erreichbar sind und \textit{wie} sie erreicht werden können. Auch Fallback-Szenarien sind durch dynamische Routing-Protokolle abgedeckt. Meist werden Backup-Routen schon im Speicher vorgehalten, um bei Ausfall einer Verbindung das Routing zu \textit{schwenken}. Man spricht auch von \textit{Routing-Konvergenz}.

\textbf{\underline{Border Gateway Protocol v4 (BGP)}}\\
Im Folgenden soll das Routing-Protokoll \gls{BGP} betrachet werden. Dieses ist durch die Public Cloud-Provider vorgegeben, wenn dynamisches Routing gewünscht ist. Es ist ein so genanntes \gls{AS}-Pfadvektorprotokoll. \gls{AS} steht dabei für Autonomous System: Ein \gls{AS} kann als eine administrative \glqq Grenze\grqq{} für eine Gruppe von Routern aufgefasst werden. Tauschen Router per \gls{BGP} Routing-Informationen aus, spricht man auch von einem \textit{BGP-Peering}. Man unterscheidet an dieser Stelle zwischen internal \gls{BGP} (iBGP) und external \gls{BGP} (eBGP): Peerings innerhalb eines \gls{AS} sind iBGP-Peerings, Peerings über \gls{AS}-Grenzen hinweg sind eBGP-Peerings. iBGP dient dem Zweck, per eBGP gelernte Routen (\textit{(BGP-)Präfixe}) innerhalb eines \gls{AS} weiterzutragen.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.75]{Figures/ebgp_peerings.pdf}
  \caption{Verschiedene AS signalisieren Erreichbarkeit für Präfixe}
  \label{grafik: ebgp_peerings}
\end{figure}\FloatBarrier

Wie man auf der Abbildung \ref{grafik: ebgp_peerings} erkennt, werden drei Präfixe aus drei verschiedenen \gls{AS} bekannt gemacht. Der \gls{AS}-Pfad zeigt an, über welche \gls{AS} ein Präfix erreicht werden kann. \textit{i} steht dabei für internal und stellt den Ursprung des Präfixes dar. Der Pfad wird von rechts (Ursprung) nach links gelesen.\cite{odom2010}\\
\textit{Anmerkung}: R2-AS10 kann mit dem Next-Hop 10.0.0.1 aus der Tabelle nichts anfangen: Dieser ist nur für R1-AS10 erreichbar. Im iBGP nutzt man daher das Attribut \textit{Next-Hop-Self}, womit iBGP-Nachbarn signalisiert wird, dass Next-Hop-Erreichbarkeit für ein Präfix \textit{über einen selbst} gegeben ist.\cite[S.468-471]{odom2010}\\
Die Next-Hop IP für Präfixe anderer \gls{AS} zeigt bei R2-AS10 somit auf die IP von R1-AS10.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.75]{Figures/ebgp_peerings_additional_connection.pdf}
  \caption{Gleicher Grundaufbau wie in Listing \ref{grafik: ebgp_peerings} mit zusätzlicher Verbindung}
  \label{grafik: ebgp_peerings_additional_connection}
\end{figure}\FloatBarrier

In Listing \ref{grafik: ebgp_peerings_additional_connection} wurde noch eine Verbindung zwischen \gls{AS} 10 und \gls{AS} 30 hinzugefügt. Damit werden alle Präfixe, bis auf die eigenen, doppelt sichtbar, da sie nun über verschiedene Pfade erreicht werden können. Im Standardfall wird das Präfix mit dem kürzeren \gls{AS}-Pfad bevorzugt.\\
Die Präfixe mit roter Schrift sind dabei allerdings nicht wertlos. Sie können als Backup-Pfad dienen, falls der bessere Pfad wegfallen sollte. Falls bspw. die Verbindung zwischen \gls{AS} 10 und \gls{AS} 30 ausfällt, \textit{konvergiert} das \gls{BGP} auf allen Routern wieder hin zum Beispiel aus Abbildung \ref{grafik: ebgp_peerings}.\\
BGP-Router ignorieren \gls{AS}-Pfade, in denen die eigene \gls{AS}-Nummer bereits vorkommt. Pakete werden dann gemäß \gls{RFC} 4271 verworfen. Dadurch werden effektiv Routing-Schleifen verhindert\cite{rfc4271}.\\
BGP sieht analog zu \gls{RFC} 1918-Adressen Bereiche für \gls{AS}-Nummern vor, die privat, also nicht im Internet, verwendet werden dürfen. Diese Nummern sind in \gls{RFC} 6996 gelistet und gehen von einschließlich 64512 bis 65534\cite{rfc6996}.

\subsection{Network Address Translation (NAT)}
Grundlegend geht es bei \gls{NAT} darum, eine IP-Adresse \textit{umzuschreiben}. Dies ist sowohl für die Absender- als auch die Ziel-Adresse möglich. Dies kann verschiedene Gründe haben, oftmals geht es aber darum, IPv4-Adressen einzusparen.\\
Dies ist dem Umstand geschuldet, dass IPv4 nur einen Adressraum von 32 Bit hat, was $2^{32} \approx 4*10^9$ Adressen entspricht. Wenn man dagegen hält, dass die Weltbevölkerung zum Zeitpunkt der Arbeit knapp $8*10^9$ Menschen beträgt und viele Menschen bereits mehr als ein Endgerät besitzen, reicht der Adressraum bei weitem nicht mehr aus \cite{weltbevoelkerung2020dsw}.\\
Langfristig soll IPv6 mit einem Adressraum aus $2^{128}$ Bit IPv4 ablösen, doch selbst im Jahr 2021 fehlt weiterhin die \textbf{vollständige Unterstützung} einiger Hersteller für IPv6. Dies gilt ebenso für Public Cloud-Plattformen.\\
Der häufigste \gls{NAT}-Mechanismus ist Network Address Port Translation (NAPT). Dabei können $n$ \gls{Client}s hinter einer einzigen IPv4-Adresse \glqq verborgen\grqq{} und so IP-Adressen eingespart werden. Dafür werden neben der IP-Adresse bspw. noch Information der Transport-Schicht (Schicht 4) wie Ports herangezogen, um NAPT-Sessions zuordnen zu können. Ein Router verwaltet diese Sessions in Form einer NAPT-Tabelle. Diese wird notwendig, wenn Rückpakete die verborgenen \gls{Client}s erreichen sollen.\\
In dieser Ausarbeitung ist, wenn von \gls{NAT} oder \gls{NAT}ting gesprochen wird und keine anderweitigen Aussagen getroffen werden, der NAPT-Mechanismus gemeint.\\
Im Beispiel von Abbildung \ref{grafik: napt} werden drei \gls{Client}s hinter einem Router ge\gls{NAT}tet. Alle eingehenden Pakete werden auf die Quell-IP 10.1.0.1 umgeschrieben und es wird ein neuer Quell-Port vergeben. Wenn nun eine Verbindung von einem \gls{Client} initiiert wird, sieht der Webserver lediglich die Quell-IP und den Quell-Port des Routers, welche durch das \gls{NAT} vergeben wurden.\\
Rückpakete vom Webserver zu einem \gls{Client} werden folgerichtig an den Router adressiert, welcher wiederum in der \gls{NAT}-Tabelle nachschlägt, um den ursprünglichen \gls{Client} (interne Absender-IP 10.0.0.x und Quell-Port) herauszufinden. Bevor Pakete also nach intern weitergeschickt werden können, werden sie auf das ursprüngliche Tupel aus Quell-IP und Quell-Port umgeschrieben.\\

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.90]{Figures/napt.pdf}
  \caption{Beispiel für Network Address Translation}
  \label{grafik: napt}
\end{figure}\FloatBarrier

NAT\label{nat-bad} verletzt das Prinzip der Ende-zu-Ende-Konnektivität: Findet sich für ein \textbf{vom Webserver kommendes} Paket in der \gls{NAT}-Tabelle kein Eintrag, wird das Paket verworfen. Dies ist bei einer \gls{Client}-zu-Server-Kommunikation oftmals kein Problem, da Verbindungen ohnehin vom \gls{Client} initiiert werden und sich daraufhin ein State in der \gls{NAT}-Tabelle des Routers befindet.\\
Wenn allerdings eine \gls{Client}-zu-\gls{Client}-Kommunikation stattfinden soll, ist man auf aufwändige Mechanismen wie z.B. Hole Punching angewiesen \cite[S.317]{Fall2011}.\\
Auf \gls{NAT} soll daher in dieser Arbeit verzichtet werden, wenn dies möglich ist und es soll eine vollwertige Ende-zu-Ende-Konnektivität gewährleistet werden.

\subsection{Maximum Transmission Unit / Maximum Segment Size}\label{mtumss}
Die maximale Paketgröße auf einem Netzwerkmedium wird durch die Maxmimum Transmission Unit (MTU) beschrieben. Im Ethernet ist die \textit{Default}-MTU 1500 Byte.\cite[S.86]{Fall2011} Ethernet ist im Internet inzwischen das meistgenutzte Medium, daher haben sich auch hier diese 1500 Byte manifestiert.\\
Da die MTU auf dem Weg vom Empfänger zum Ziel variieren und auch mal geringer als 1500 Byte ausfallen kann, kann ein IPv4-Paket \textit{fragmentiert} werden. Dieser Prozess fordert Rechenzeit für Aufteilung und (Wieder-)Zusammensetzung in Fragmente und kann sich negativ auf die Performance (Latenz und Datendurchsatz) auswirken.\\
Man nutzt optimalerweise Path MTU Discovery oder beeinflusst die Maximum Segment Size für \gls{TCP} (\glqq \gls{MSS}-Clamping\grqq{}) bei Initiierung der Verbindung, um Fragmentierung (bestmöglich) zu umgehen.

\subsection{GeoIP}
Mit Hilfe von \gls{GeoIP}-Datenbanken ist es möglich, den (ungefähren) Standort anhand der Absender-IP-Adresse eines \gls{Client}s zu bestimmen. Verwendung finden solche Datenbanken häufig bei Internet-Streaming-Anbietern, um Zugriffe auf ein Videoangebot aus dem Ausland zu verhindern. Die Firma MaxMind ist dabei führender Anbieter für solche \gls{GeoIP}-Datenbanken \cite{maxmind2021geoip}.

\section{Domain Name System (DNS)}\label{DNS}
Das \gls{DNS} ermöglicht, Server im Internet anhand eines Namens, dem Fully Qualified Domain Name (\gls{FQDN}), zu erreichen. Somit muss sich ein Benutzer einer Webseite keine IP-Adresse merken, sondern lediglich den dazugehörigen \gls{FQDN}. Die IP-Adresse wird über die \textit{DNS-Auflösung} herausgefunden. Das \gls{DNS} ist ein hierarchisches Modell, welches mit Domains arbeitet. Diese unterliegen unterschiedlichen Autoritäten. 
\begin{figure}[h]
  \centering
  \includegraphics{Figures/dns_autoritative.pdf}
  \caption{DNS-Hierarchie}
  \label{grafik: dns-hierarchy}
\end{figure}\FloatBarrier

Soll z.B. der \gls{FQDN} www.intern.ba.mungard.de. aufgelöst werden (s. Abb. \ref{grafik: dns-hierarchy}), muss der \textit{Baum} von der Wurzel \glqq .\grqq{} über die Knoten \glqq de\grqq{}, \glqq mungard\grqq{}, ... bis zum Blatt \glqq www\grqq{} durchlaufen werden. Man spricht von einer iterativen Auflösung. Pro Hierarchie-Ebene sind \textit{autoritative Nameserver} verantwortlich für die richtige Delegation des auflösenden \gls{Client}s.\\
Das Blatt \glqq www\grqq{} wird auch als Resource Record bezeichnet. Für diese Arbeit sind lediglich A-Records relevant, welche \gls{FQDN} nach IPv4-Adresse auflösen. Viele weitere \gls{DNS}-Records existieren, z.B. für IPv6-Adressen (AAAA) oder um Mailserver (MX) für eine Domain anzugeben \cite[S.528]{Fall2011}.\\
Ein Beispiel für einen autoritativen Nameserver ist Bind \cite{liu2006dns}. Innerhalb des Nameservers werden Domains anhand von \textit{Zonen(-Dateien)} verwaltet.
\newpage
\subsection{DNS-Resolver}
\gls{Client}s machen diese iterative Namensauflösung typischerweise nicht selbst, sondern leiten ihre Anfragen an einen \gls{DNS}-Resolver weiter (\textit{Forwarding}). Dieser sucht \textit{iterativ} zu einem \gls{FQDN} eine IPv4-Adresse und liefert sie dem \gls{Client} aus (s. Abb. \ref{grafik: dns-resolver}). Wenn ein Nameserver für eine gesuchte Domain nicht autoritativ ist, wird der Resolver per NS Record weiterdelegiert.\\
Weiterhin kann ein Resolver Einträge \textit{cachen}, um auf erneute Anfragen für gleiche \gls{FQDN} schneller zu antworten.
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.7]{Figures/dns_recursion.pdf}
  \caption{DNS-Resolver}
  \label{grafik: dns-resolver}
\end{figure}\FloatBarrier
%TC:ignore
In Listing \ref{dig-example-fh-kiel} wird ein A-Record für die Domain www01.fh-kiel.de gegen den Resolver von Google (8.8.8.8) mit dem Werkzeug \texttt{dig} aufgelöst.
\begin{listing}[h]
\begin{minted}[breaklines,frame=single]{bash}
$ dig www01.fh-kiel.de @8.8.8.8 | grep -v '^$'
; <<>> DiG 9.11.9 <<>> www01.fh-kiel.de @8.8.8.8
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 11777
;; flags: qr rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1
;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;www01.fh-kiel.de.              IN      A
;; ANSWER SECTION:
www01.fh-kiel.de.       21599   IN      A       149.222.20.63
;; Query time: 60 msec
;; SERVER: 8.8.8.8#53(8.8.8.8)
;; WHEN: Tue May 18 22:21:45 CEST 2021
;; MSG SIZE  rcvd: 61
\end{minted}
\caption{DNS-Auflösung für einen A-Record gegen den Resolver von Google}
\label{dig-example-fh-kiel}
\end{listing}\FloatBarrier
%TC:endignore

\subsection{Split \gls{DNS}}
Split \gls{DNS} ist die Möglichkeit, verschiedene Resource Records anhand der Absender-IP auszuliefern. Dafür pflegen autoritative Nameserver Access Control Lists (\gls{ACL}) mit verschiedenen IP-Präfixen, um eine Fallunterscheidung treffen zu können\cite[S.565-567]{Fall2011}. Dies ist z.B. relevant, wenn eine Firma zwischen internen und externen Anfragen unterscheiden muss, um den (richtigen) Zugriff auf Ressourcen zu gewährleisten.

\begin{figure}[h]
  \centering
  \includegraphics{Figures/dns_split_view.pdf}
  \caption{Split DNS für portal.firma.de.}
  \label{grafik: split-dns}
\end{figure}\FloatBarrier

\subsection{DNS UPDATE}
Die Methode \gls{DNS} UPDATE ist in \gls{RFC} 2136 definiert und erlaubt es, autoritative Zonen eines Nameserver zur Laufzeit zu verändern\cite{rfc2136}. Somit müssen keine Zonen-Dateien manuell angepasst werden. Außerdem muss der Nameserver nicht neugestartet werden, um die editierten Zonen-Dateien neu einzulesen.\\
\gls{Client}s werden über eine \gls{ACL} ermächtigt, diese Updates zu tätigen. Dabei kann die Absender-IP zur Authentifizierung genutzt werden: Allerdings ist diese Methode unsicher, da sich IPs \textit{spoofen}, d.h. fälschen, lassen\cite[S.70-71]{Fall2011}. Sicherer ist es, mit Hilfe eines vorab ausgetauschten Schlüssels (\textit{Pre-Shared Key}) eine \gls{DNS} UPDATE-Nachricht zu signieren. Dies passiert mit Hilfe von Transaction Signatures (\gls{TSIG})\cite[S.911-914]{Fall2011}.

\section{Virtual Private Network (VPN)}\label{vpn}
\gls{VPN}s werden genutzt, um private Netzwerke über eine öffentlich genutzte Infrastruktur abbilden zu können. Dies erfolgt zwischen \gls{VPN}-Endpunkten über gängige Enkapsulierungen, z.B. Generic Routing Encapsulation (GRE), Encapsulating Security Payload (ESP) oder OpenVPN.\\
In Abbildung \ref{grafik: vpn-example} werden Daten von \gls{Client} A zu \gls{Client} B über das Internet zwischen Router R1 und Router R2 enkapsuliert. R2 empfängt das Datenpaket, packt es aus und sendet es in der ursprünglichen Form weiter an \gls{Client} B.\\
Das Diagramm ist dabei nicht spezifisch für eine bestimmte \gls{VPN}-Technologie. Es können, je nach Technologie, Nutzdaten verschlüsselt werden. 
\begin{figure}[h]
  \centering
  \includegraphics[scale=0.65]{Figures/vpn-example.pdf}
  \caption{Übertragung eines IP-Pakets über einen VPN-Tunnel}
  \label{grafik: vpn-example}
\end{figure}\FloatBarrier

Die in dieser Arbeit verwendeten \gls{VPN}\-Technologien sind Internet Protocol Security (\gls{IPsec}) und OpenVPN. \gls{IPsec} wird u.a. für die Vernetzung von (Cloud-)Standorten, auch \gls{Site-to-Site} genannt, genutzt und arbeitet auf \glslink{OSI-Schichtenmodell}{OSI-Schicht} 3. Ebenso dient es zur \textit{Einwahl} in (Firmen-)Netzwerke. \gls{IPsec} wird meist im Geschäftsumfeld genutzt und es exisitieren viele herstellerabhängige Implementationen.\\
OpenVPN ist ein Open Source-Projekt und es nutzt \textit{Transport Layer Security} (TLS) für die verschlüsselte Übertragung von Daten via \gls{UDP} oder \gls{TCP}. Das Protokoll ist auf \glslink{OSI-Schichtenmodell}{OSI-Schicht} 7 zu finden und es wird vor allem für \gls{Client-to-Site}-Verbindungen genutzt: Passende Software ist für viele verschiedene Plattformen verfügbar (u.a. Windows, Linux, Mac, Android) und sowohl \gls{Client}- als auch Server-Applikation sind kostenfrei erhältlich.\\
Angesprochene MTU-Probleme (s. \ref{mtumss}) können sich bei einer getunnelten Verbindung auf Grund des zusätzliches \textit{Overheads} auf Grund der Enkapsulierung zeigen. Eine IP-Fragmentierung sollte optimalerweise verhindert werden.

\section{Cloud}\label{cloud}
Der Cloud-Begriff kann je nach Literatur variieren. Diese Arbeit verweist an dieser Stelle auf die Definition des \textit{National Institute of Standards and Technology (NIST)}. Ebenso werden dort die drei typischen \textit{Cloud Delivery}-Modelle Software as a Service (SaaS), Platform as a Service (PaaS) und Infrastructure as a Service (IaaS) definiert, welche fortan als bekannt vorausgesetzt werden.\cite{mell2011}

\subsection{Public und Private Cloud}
Auch für die so genannten \textit{Cloud \gls{Deployment}}-Modelle wird auf die Definition des NIST verwiesen.\cite{mell2011}\\
Allerdings soll an dieser Stelle auf ein häufiges Missverständnis hingewiesen werden: Eine Private Cloud existiert nicht zwingend \textit{\gls{on-premises}} einer Organisation, also bspw. im eigenen Rechenzentrum. Sie kann ebenso über Public Cloud-Plattformen abgebildet werden. Allerdings ist die Voraussetzung, dass alle genutzten Ressourcen dann exklusiv für die Organisation zur Verfügung stehen (\textit{exclusive use by a single organization}). Sie werden nicht mit weiteren Parteien geteilt (\textit{open use by the general public}).\\
Die Public Cloud-Provider, welche in dieser Arbeit genutzt werden, sind Amazon Web Services (AWS) und Microsoft Azure. Rechenzentren stehen weltweit zur Verfügung, um eine schnelle und latenzarme Anbindung für die Kunden zu ermöglichen. Eine Private Cloud lässt sich bspw. mit OpenStack abbilden\cite{sefraoui2012openstack}.

\subsection{Multi und Hybrid Cloud}
Eine Multi Cloud vernetzt \textbf{gleiche} Cloud \gls{Deployment}s miteinander, z.B. Public Cloud 	$\leftrightarrow$ Public Cloud oder Private Cloud $\leftrightarrow$ Private Cloud.\\
Bei einer Hybrid Cloud werden unterschiedliche Bausteine zusammengefasst. In dieser Arbeit soll eine Hybrid Cloud aus AWS, Azure (Public) und Private Cloud bereitgestellt (\glqq {Deployment}\grqq{}) werden.

\section{Public Cloud-Netzwerke}\label{public-cloud-networking}
In diesem Kapitel wird näher auf die verschiedenen Netzwerk-\textit{Building Blocks} der Public Cloud-Plattformen AWS und Azure eingegangen. Beide bringen oftmals ähnliche Bausteine mit. Es wird daher stets versucht, im jeweiligen Kontext auf beide Plattformen zugleich einzugehen, um die Grundfunktionalität zu erläutern.
Dieses Kapitel vermittelt lediglich Grundlagen, die für das Verständnis der Use-Cases in Kapitel \ref{Defintion der Use-Cases} und Kapitel \ref{Umsetzung der Use-Cases und Evaluation} notwendig sind. Besonderheiten und Constraints, die sich im Verlauf der Bearbeitung ergeben haben, werden im jeweiligen Use-Case unter \glqq Probleme und Lösungsfindung\grqq{} zusammengefasst.

\subsection{AWS \gls{VPC} / Azure \gls{VNET}}
AWS Virtual Private Cloud (VPC) und Azure Virtual Network (VNET) bilden private Netzwerke innerhalb eines Cloud-Mandanten ab. Die hier hinterlegten Präfixe bilden eine Menge an möglichen IP-Adressen innerhalb von \gls{VPC} und \gls{VNET} ab. Es können sowohl Public IP-Präfixe als auch IPs nach \gls{RFC} 1918 benutzt werden. Diese Menge an IP-Adressen wird in AWS \textit{\gls{CIDR}} bzw. Azure \textit{Address Space} als Container zusammengefasst.\\
AWS gibt /16 als minimale und /28 als maximale Größe des \gls{CIDR} vor \cite[S.100]{awsug2020}. Azure \gls{VNET} ist da großzügiger und es darf eine Größe zwischen /8 und /29 gewählt werden\cite[S.10]{Toroman2019}. 
\subsection{Subnets}
Innerhalb von \gls{VPC} und \gls{VNET} können Subnets angelegt werden. In diesen Subnets können bspw. virtuelle Maschinen mit IPs ausgestattet werden. Wenn also ein \gls{VPC} einen \gls{CIDR}-Block von 10.0.0.0/16 besitzt, kann z.B. ein Subnet 10.0.1.0/24 \glqq herausgeschnitten\grqq{} werden. Mit Subnets können weitere Objekte verknüpft werden wie z.B. Route Tables, welche das Routing für das Subnet steuern.

\subsection{Route Tables}
Route Tables ermöglichen es, den Fluss von IP-Pakete innerhalb eines Subnets zu steuern. So können z.B. statische Routen auf Ziele innerhalb eines Subnets angelegt werden. \gls{VNET} kann dies, wie aus dem klassischen Netzwerk gewohnt, über Next-Hop IPs abbilden. \gls{VPC} hingegen unterstützt als Next-Hop virtuelle Maschinen (Instances) und Interfaces von virtuellen Maschinen. Es existieren noch weitere spezielle Ziele, die genutzt werden können wie z.B. \gls{VPN} Gateways, um entfernte Netzwerke zu erreichen.\\
Subnets in Azure erfordern keine Route Tables: Alle Maschinen eines \gls{VNET} erreichen sich untereinander standardmäßig und erreichen Ressourcen im Internet. Sollte ein granulareres Routing notwendig sein, werden Azure Route Tables erforderlich.\\
Subnets in \gls{VPC} erhalten immer eine Route Table: Ohne weitere Konfigurationen wird einem Subnet die Main Route Table zugewiesen. Diese kann vorab editiert werden, so dass z.B. kein Internet-Traffic für virtuelle Maschinen möglich ist. \textit{Non-Main} Route Tables können für spezielle Anforderungen erstellt und Subnets zugewiesen werden.

\subsection{Security Groups}
AWS Security Groups (SG) bzw. Azure Network Security Groups (\gls{NSG}) bilden \textit{stateful Firewalling} ab \cite{wool2006packet}. Dabei können sowohl ingress (eingehende), als auch egress (ausgehende) Firewall-Regeln definiert und darauf basierend Pakete gefiltert werden. Typische Protokolle anhand derer Regeln definiert werden können sind \gls{UDP}, \gls{TCP} und \gls{ICMP}.\\
AWS \gls{SG}s können einer Instanz zugewiesen werden. Wird keine \gls{SG} explizit für eine Instanz definiert, kommt eine Default \gls{SG} zu Einsatz, die vom \gls{VPC} vorgegeben ist.\\
Azure \gls{NSG}s können sowohl Subnets als auch \gls{VM}s direkt zugewiesen werden. \gls{NSG}s für Subnets wirken sich global für alle \gls{VM}s eines Subnets aus. Wenn granularer Zugriff auf bestimmte \gls{VM}s gewünscht ist, nutzt man zusätzliche \gls{NSG}s \glqq auf\grqq{} den jeweiligen Instanzen.

\subsection{VPN}
AWS bringt in Form von Virtual Private Gateway und Transit Gateway Möglichkeiten mit, \gls{IPsec}-basierte \gls{Site-to-Site}-Verbindungen zu terminieren. Ersteres kann Verbindungen nur innerhalb eines \gls{VPC} terminieren. Transit Gateway bietet die Möglichkeit, verschiedene \gls{VPC}s miteinander zu \textit{peeren}. \gls{VPN}-Verbindungen können auf Transit Gateway terminiert werden und Pakete, die über \gls{VPN} reinkommen, können alle gepeerten \gls{VPC}s erreichen.\\
Azure Virtual network gateway kann analog zu AWS Virtual Private Gateway \gls{IPsec}-Tunnel in einem \gls{VNET} terminieren.\\
AWS und Azure ermöglichen innerhalb der Tunnel die Nutzung von \gls{BGP}, um dynamische Routing-Informationen miteinander auszutauschen.


\section{Automatisierung}\label{automatisierung}

Diverse Automatisierungswerkzeuge ermöglichen es, gewünschte Endzustände von Systemen zu definieren. Mit heutigen Werkzeugen wie z.B. \textit{Ansible} muss ein Administrator wenig Programmiererfahrungen mitbringen und schreibt die gewünschten Parameter in eine Konfigurationsdatei, die zu einem gewünschten Zeitpunkt auf Systemen ausgerollt werden. Viele Probleme wurden bereits von anderen Community-Mitgliedern gelöst. Für komplexere Sachverhalte existieren Plugins.\\
Man muss bei Automatisierungswerkzeugen zwischen \textit{Configuration Management} (CM) und \textit{Provisioning} unterscheiden. Provisioner dienen der grundsätzlichen Erstellung einer Infrastruktur, während \gls{CM}-Werkzeuge diese Infrastruktur als vorhanden annehmen und weitere Konfigurationen auf den jeweiligen Komponenten tätigen\cite[S.20]{Brikman2019}.\\
Eine Analogie wäre: Provisioner setzen das Haus an eine Straße und das \gls{CM} macht daraufhin die Innenaustattung. Auf die IT angewendet bedeutet dies, dass Provisioner dafür sorgen, dass Ubuntu-Maschinen aufgesetzt werden und zu erreichen sind. Das \gls{CM} macht daraufhin Paket-Updates und installiert z.B. einen Apache-Webserver.\\
Es gibt keine eindeutige Linie zwischen den beiden Typen von Werkzeugen. So können viele \gls{CM}-Werkzeuge auch ein Provisioning von Infrastruktur abbilden, während Provisioner auch grundlegendes Configuration Management leisten können\cite[S.20]{Brikman2019}. Das bereits angesprochene Ansible ist ein \gls{CM}-Tool mit eingeschränkter Provisioning-Funktionalität.\\
Passende Schnittstellen, z.B. in Form einer REST-API, sind Voraussetzung, um Automatisierungswerkzeuge mit entsprechenden Komponenten nutzen zu können.

\subsection{Terraform}
Das Werkzeug, das hauptsächlich für Automatisierungs-Schritte in dieser Arbeit verwendet wird, ist \textit{Terraform} der Firma Hashicorp. Es ist ein Provisioner mit begrenzten Möglichkeiten für Configuration Management. Es besitzt eine Vielzahl an \textit{Resources}, welche es ermöglichen, Infrastruktur-Komponenten reproduzierbar bereitzustellen. Es wird eine deklarativer Sprachstil genutzt, um gewünschte Zustände der Infrastruktur zu beschreiben. Man spricht auch von \textit{Infrastructure as Code} (IaC).

\textbf{\underline{Provider}}\label{tf-provider}\\
Provider sind die Grundvoraussetzung, um die Automatisierung einer Plattform mit Terraform bewerkstelligen zu können. Sie ermöglichen es, mit entsprechenden Schnittstellen der Anbieter, z.B. REST, zu interagieren. Provider liefern meist diverse \textit{Resources} mit, welche Veränderungen tätigen können und \textit{Data Sources}, welche \glqq lesend\grqq{} auf die Infrastruktur zugreifen, um Informationen zurückzuliefern. Diese Informationen können dann anderen \textit{Modulen} zur Verfügung gestellt werden.\cite{Brikman2019}\\
Terraform arbeitet stateful: Nach jedem \texttt{terraform apply}, welches zur Erstellung der gewünschten Infrastruktur führt, werden Referenzen aller Infrastrukturkomponenten in der Datei \underline{terraform.tfstate} gespeichert: Ein erneuter Aufruf von \texttt{terraform apply} würde, insofern keine Konfigurationsänderungen gemacht wurden, die Infrastruktur so belassen und sie nicht nochmals bereitstellen bzw. erweitern. Per \texttt{terraform destroy} kann die Infrastruktur wieder zurückgebaut werden.\\
In Listing \ref{tf-aws-provider-example} wird der Provider \textit{aws} in einer spezifischen Version eingebunden. Der Constraint \glqq $\sim$>\grqq{} sorgt dafür, dass nur Versionen des Providers innerhalb des 3.35.x Branches benutzt werden (\glqq Minor Patches\grqq{}).
%TC:ignore
\begin{listing}[h]
\begin{minted}[breaklines,frame=single]{tf}
terraform {
    required_providers {
        aws = {
            source = "hashicorp/aws"
            version = "~> 3.35.0"
        }
    }
}
\end{minted}
\caption{Terraform AWS Provider}
\label{tf-aws-provider-example}
\end{listing}
%TC:endignore

\textbf{\underline{Resources}}\\
Resources erstellen Infrastuktur-Komponenten und statten diese mit den richtigen Parametern aus. In Listing \ref{deployment_aws_tf} wird ein \gls{VPC} mit dem \gls{CIDR}-Block 10.0.0.0/16 und ein darunterliegendes Subnet 10.0.1.0/24 erstellt.
%TC:ignore
\begin{listing}[h]
\begin{minted}[breaklines,frame=single]{tf}
resource "aws_subnet" "example_subnet" {
    vpc_id            = aws_vpc.example_vpc.id
    cidr_block        = "10.0.1.0/24"
    availability_zone = "eu-central-1"
}
resource "aws_vpc" "example_vpc" {
    cidr_block = "10.0.0.0/16"
}
\end{minted}
\caption{Deployment der Resources \glqq example\_vpc\grqq{} und \glqq example\_subnet\grqq{}}
\label{deployment_aws_tf}
\end{listing}
%TC:endignore
Dabei zeigt sich auch der deklarative Aspekt von Terraform. Die Resource \glqq aws\_subnet\grqq{} mit dem Namen \glqq example\_subnet\grqq{} kommt als erstes im Code vor, referenziert jedoch das \gls{VPC} \glqq example\_vpc\grqq{}. Durch diese impliziete Abhängigkeit wird die Resource \glqq example\_vpc\grqq{} als erstes erstellt. Man beschreibt also, \textit{was} benötigt wird. \textit{Wie} und in welcher Reihenfolge das Rollout gemacht wird, obliegt Terraform.

\textbf{\underline{Module}}\\
Terraform Module sind \textit{Container}, die mehrere Resources in *.tf-Dateien zusammenfassen \cite{tfmodule2021}. Es ist zwar möglich, alle notwendigen Resources in einer einzigen *.tf-Datei zu konfigurieren, allerdings ist es \textit{best practice}, verschiedene Resources der Übersichtlichkeit wegen aufzuteilen und in einer geeigneten Ordnerstruktur unterzubringen. Die jeweiligen Dateien innerhalb eines Ordners heißen dann \underline{main.tf}. Um Attribute an andere Module weiterzugeben, werden \textit{Outputs} genutzt. 

\textbf{\underline{Data Sources und Outputs}}\\
Data Sources führen keine Änderung herbei, sondern werden genutzt, um detaillierte Informationen zu Infrastruktur-Komponenten zurückzugeben oder um etwas zu finden. In Listing \ref{data-source-find-output-id} wird mit Hilfe der Data Source \glqq ubuntu\grqq{} nach einem Amazon Machine Image (AMI) für Ubuntu gesucht. Die ID (image\_id) für das \textit{most recent} Release wird per Output an andere Module übergeben. Diese können die ID dann z.B. nutzen, um per Resource eine virtuelle Maschine mit dem gewünschten Ubuntu-Image bereitzustellen.
%TC:ignore
\begin{listing}[h]
\begin{minted}[breaklines,frame=single]{tf}
data "aws_ami" "ubuntu" {
  most_recent = true
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
  owners = ["099720109477"] # Canonical
}
output "ubuntu_ami_id" {
  value = data.aws_ami.ubuntu.image_id
}
\end{minted}
\caption{Suche nach einem Amazon Machine Image für Ubuntu}
\label{data-source-find-output-id}
\end{listing}\FloatBarrier
%TC:endignore
\subsection{IP Address Management (IPAM)}
Ein \gls{IPAM} ist wichtig, insofern die Adressverwaltung automatisiert werden soll. Statisch konfigurierte \gls{CIDR}-Blöcke im Code sorgen für eine schlechte Wiederverwendbarkeit und Skalierbarkeit von Modulen: IP-Blöcke müssten dann jedes Mal händisch reserviert und in den gewünschten Modulen untergebracht werden.\\
Einfacher ist es, im Modul lediglich festzulegen, welche Subnetzgröße erforderlich ist: ein \gls{IPAM} gibt dann den nächsten freien Block in der passenden Größe zurück. Es wird lediglich ein großer Block vorreserviert, aus dem die freien Blöcke entnommen werden können.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.8]{Figures/ipam_cake.pdf}
  \caption{IPAM-Reservierung von \gls{CIDR}-Blöcken}
  \label{grafik: ipam_ip_reservation}
\end{figure}\FloatBarrier
